using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Linq;
using containersec;
using static System.Console;

namespace containersec
{
    public static class VulnerabilityAnalysis
    {

        public static async Task ProcessImages(DirectoryInfo logLocation)
        {
            await foreach(var image in Anchore.GetImages())
            {
                var vulnerabilities = await Anchore.GetVulnerabilitiesForImage(image);
                var result = VulnerabilityStore.Save(logLocation,image,vulnerabilities);
                if (result)
                {
                    WriteLine($"Saved: {image.Tag}; {image.Digest}");
                }
                else
                {
                    WriteLine($"Not saved: {image.Tag}; {image.Digest}");
                }
            }
        }

        public static async Task DiffVulnerabilities()
        {
            var imageDictionary = await GetAggregatedImages();
            List<ImageInfo> images;
            foreach (var imageSet in imageDictionary.Values)
            {
                if (imageSet.Count == 1)
                {
                    WriteLine($"Only 1 image found for {imageSet[0].Tag}.");
                }
                else
                {
                    
                }
                images = imageSet.OrderBy(i => i.TimeStamp).ToList();


            }
        }

        private static DiffVulnerabilitiesForTwoImages(ImageInfo imageA, ImageInfo imageB)
        {
            var vulnerabilitiesA = VulnerabilityStore.LoadVulnerabilitiesForDigest();
        }

        private static async Task<Dictionary<string, List<ImageInfo>>> GetAggregatedImages()
        {
            var images = new Dictionary<string, List<ImageInfo>>();
            
            await foreach (var image in Anchore.GetImages())
            {
                if (images.TryGetValue(image.Tag, out var list))
                {
                    list.Add(image);
                }
                else
                {
                    images.Add(image.Tag, new List<ImageInfo>(){image});
                }
            }
            return images;
        }

        public static VulnerabilitySummary GetSummary(List<Vulnerability> vulnerabilities)
        {
            var summary = new VulnerabilitySummary();

            foreach (var vuln in vulnerabilities)
            {
                switch (vuln.severity)
                {
                    case "Critical":
                        summary.Critical++;
                        break;
                    case "High":
                        summary.High++;
                        break;
                    case "Medium":
                        summary.Medium++;
                        break;
                    case "Low":
                        summary.Low++;
                        break;
                    case "Negligible":
                        summary.Negligible++;
                        break;
                    case "Unknown":
                        summary.Unknown++;
                        break;
                    default:
                        throw new Exception();
                };
            }

            return summary;
        }

        public static (bool, int) GetCountForSeverityLevel(VulnerabilitySummary summary, string severity)
        {
            var count = 0;
            switch (severity.ToLowerInvariant())
            {
                case "critical":
                    count = summary.Critical;
                    break;
                case "high":
                    count = summary.High;
                    break;
                case "medium":
                    count = summary.Medium;
                    break;
                case "low":
                    count = summary.Low;
                    break;
                case "negligible":
                    count = summary.Negligible;
                    break;
                case "Unknown":
                    count = summary.Unknown;
                    break;
                default:
                    return (false, 0);
            };

            return (true, count);
        }

    }   
}