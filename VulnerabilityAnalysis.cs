using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Linq;
using containersec;
using static System.Console;

namespace containersec
{
    public static class VulnerabilityAnalysis
    {

        public static async Task ProcessImages(DirectoryInfo logDir)
        {
            var imageSet = await Anchore.GetAggregatedImages();
            foreach(var tagKey in imageSet.Keys)
            {

                var images = imageSet[tagKey];

                for (int i = 0; i < images.Count;i++)
                {
                    var image = images[i];
                    var vulnerabilities = await Anchore.GetVulnerabilitiesForImage(image);
                    var result = VulnerabilityStore.Save(logDir,image,null,vulnerabilities);
                    WriteLine($"{image.Tag}; {image.Digest}; New: {result}");

                    if (i+1 >= images.Count)
                    {
                        continue;
                    }

                    for (int j = i+1; j < images.Count;j++)
                    {
                        var image2 = images[j];
                        var vulnerabilities2 = await Anchore.GetVulnerabilitiesForImage(image);
                        var result2 = VulnerabilityStore.Save(logDir,image2,image,vulnerabilities2);
                    }
                }
            }
        }

        public static async Task DiffVulnerabilities(DirectoryInfo logDir, string tag)
        {
            var imageDictionary = await Anchore.GetAggregatedImages();
            List<ImageInfo> images = null;
            var selectedTag = string.Empty;
            foreach (var tagKey in imageDictionary.Keys)
            {
                if (tagKey.Contains(tag))
                {
                    images = imageDictionary[tagKey];
                    selectedTag = tagKey;
                    break;
                }
            }

            if (images == null)
            {
                WriteLine($"No image found for {tag}.");
            }
            else if (images.Count == 1)
            {
                WriteLine($"Only 1 image found for {tag}.");
            }
            else
            {
                WriteLine($"Diff {images.Count} images for {selectedTag}.");

                for (int i = 0; i < images.Count - 1; i++)
                {
                    await DiffVulnerabilitiesForTwoImages(logDir,images[i], images[i + 1]);
                    WriteLine();
                }
            }
        }

        private static async Task DiffVulnerabilitiesForTwoImages(DirectoryInfo logDir, ImageInfo imageA, ImageInfo imageB)
        {
            var vulnerabilitiesA = VulnerabilityStore.LoadVulnerabilitiesForDigest(logDir, imageA, null);
            var vulnerabilitiesB = VulnerabilityStore.LoadVulnerabilitiesForDigest(logDir, imageB, imageA);

            var vulnerabilitiesUniqueToA = vulnerabilitiesA.Except(vulnerabilitiesB).ToList();
            var vulnerabilitiesUniqueToB = vulnerabilitiesB.Except(vulnerabilitiesA).ToList();
            var vulnerabilitiesShared = vulnerabilitiesA.Intersect(vulnerabilitiesB).ToList();

            WriteLine($"New Image: {imageA.TimeStamp}; {imageA.Digest}");
            WriteLine($"Old Image: {imageB.TimeStamp}; {imageB.Digest}");
            WriteLine("New vulnerabilities:");
            await PrintVulnerabilitySummary(vulnerabilitiesUniqueToA);
            PrintArrayOfStrings(vulnerabilitiesUniqueToA);
            
            WriteLine("Fixed vulnerabilities:");
            await PrintVulnerabilitySummary(vulnerabilitiesUniqueToB);
            PrintArrayOfStrings(vulnerabilitiesUniqueToB);

            WriteLine("Shared vulnerabilities:");
            await PrintVulnerabilitySummary(vulnerabilitiesShared);
            PrintArrayOfStrings(vulnerabilitiesShared);

            void PrintArrayOfStrings(List<string> strings)
            {
                if (strings.Count == 0)
                {
                    WriteLine("None");
                    return;
                }

                foreach (var s in strings)
                {
                    WriteLine(s);
                }
            }

            async Task PrintVulnerabilitySummary(List<string> vulns)
            {
                if (vulns == null || vulns.Count == 0)
                {
                    return;
                }
                var vulnerabilities = await Anchore.GetVulnerabilitiesForVulns(vulns);
                var vulnSummary = GetSummary(vulnerabilities);
                WriteLine(vulnSummary);
            }
        }

        public static VulnerabilitySummary GetSummary(List<Vulnerability> vulnerabilities)
        {
            var summary = new VulnerabilitySummary();

            foreach (var vuln in vulnerabilities)
            {
                switch (vuln.severity)
                {
                    case "Critical":
                        summary.Critical++;
                        break;
                    case "High":
                        summary.High++;
                        break;
                    case "Medium":
                        summary.Medium++;
                        break;
                    case "Low":
                        summary.Low++;
                        break;
                    case "Negligible":
                        summary.Negligible++;
                        break;
                    case "Unknown":
                        summary.Unknown++;
                        break;
                    default:
                        throw new Exception();
                };
            }

            return summary;
        }

        public static (bool, int) GetCountForSeverityLevel(VulnerabilitySummary summary, string severity)
        {
            var count = 0;
            switch (severity.ToLowerInvariant())
            {
                case "critical":
                    count = summary.Critical;
                    break;
                case "high":
                    count = summary.High;
                    break;
                case "medium":
                    count = summary.Medium;
                    break;
                case "low":
                    count = summary.Low;
                    break;
                case "negligible":
                    count = summary.Negligible;
                    break;
                case "unknown":
                    count = summary.Unknown;
                    break;
                default:
                    return (false, 0);
            };

            return (true, count);
        }

    }   
}