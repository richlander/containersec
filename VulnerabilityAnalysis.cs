using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Linq;
using containersec;
using static System.Console;

namespace containersec
{
    public static class VulnerabilityAnalysis
    {

        public static async Task ProcessImages(DirectoryInfo logDir)
        {
            await foreach(var image in Anchore.GetImages())
            {
                var vulnerabilities = await Anchore.GetVulnerabilitiesForImage(image);
                var result = VulnerabilityStore.Save(logDir,image,vulnerabilities);
                if (result)
                {
                    WriteLine($"Saved: {image.Tag}; {image.Digest}");
                }
                else
                {
                    WriteLine($"Found: {image.Tag}; {image.Digest}");
                }
            }
        }

        public static async Task DiffVulnerabilities(DirectoryInfo logDir, string tag)
        {
            var imageDictionary = await GetAggregatedImages();
            List<ImageInfo> images = null;
            foreach (var tagKey in imageDictionary.Keys)
            {
                if (!tagKey.Contains(tag))
                {
                    continue;
                }

                images = imageDictionary[tagKey];
            }

            if (images == null)
            {
                WriteLine($"No image found for {tag}.");
            }
            else if (images.Count == 1)
            {
                WriteLine($"Only 1 image found for {tag}.");
            }
            else
            {
                var orderedImages = images.OrderByDescending(i => i.TimeStamp).ToList();

                for (int i = 0; i < orderedImages.Count - 1; i++)
                {
                    DiffVulnerabilitiesForTwoImages(logDir,orderedImages[i], orderedImages[i + 1]);
                }
            }
        }

        private static void DiffVulnerabilitiesForTwoImages(DirectoryInfo logDir, ImageInfo imageA, ImageInfo imageB)
        {
            var vulnerabilitiesA = VulnerabilityStore.LoadVulnerabilitiesForDigest(logDir, imageA, true);
            var vulnerabilitiesB = VulnerabilityStore.LoadVulnerabilitiesForDigest(logDir, imageB, true);

            var vulnerabilitiesUniqueToA = vulnerabilitiesA.Except(vulnerabilitiesB);
            var vulnerabilitiesUniqueToB = vulnerabilitiesB.Except(vulnerabilitiesA);
            var vulnerabilitiesShared = vulnerabilitiesA.Intersect(vulnerabilitiesB);

            WriteLine($"New Image: {imageA.TimeStamp}; {imageA.Digest}");
            WriteLine($"Old Image: {imageB.TimeStamp}; {imageB.Digest}");
            WriteLine("New vulnerabilities:");
            PrintArrayOfStrings(vulnerabilitiesUniqueToA);
            
            WriteLine("Fixed vulnerabilities:");
            PrintArrayOfStrings(vulnerabilitiesUniqueToB);

            WriteLine("Shared vulnerabilities:");
            PrintArrayOfStrings(vulnerabilitiesShared);

            void PrintArrayOfStrings(IEnumerable<string> strings)
            {
                var list = strings.ToList();

                if (list.Count == 0)
                {
                    WriteLine("No entries");
                    return;
                }

                foreach (var s in list)
                {
                    WriteLine(s);
                }
            }

        }

        private static async Task<Dictionary<string, List<ImageInfo>>> GetAggregatedImages()
        {
            var images = new Dictionary<string, List<ImageInfo>>();
            
            await foreach (var image in Anchore.GetImages())
            {
                if (images.TryGetValue(image.Tag, out var list))
                {
                    list.Add(image);
                }
                else
                {
                    images.Add(image.Tag, new List<ImageInfo>(){image});
                }
            }
            return images;
        }

        public static VulnerabilitySummary GetSummary(List<Vulnerability> vulnerabilities)
        {
            var summary = new VulnerabilitySummary();

            foreach (var vuln in vulnerabilities)
            {
                switch (vuln.severity)
                {
                    case "Critical":
                        summary.Critical++;
                        break;
                    case "High":
                        summary.High++;
                        break;
                    case "Medium":
                        summary.Medium++;
                        break;
                    case "Low":
                        summary.Low++;
                        break;
                    case "Negligible":
                        summary.Negligible++;
                        break;
                    case "Unknown":
                        summary.Unknown++;
                        break;
                    default:
                        throw new Exception();
                };
            }

            return summary;
        }

        public static (bool, int) GetCountForSeverityLevel(VulnerabilitySummary summary, string severity)
        {
            var count = 0;
            switch (severity.ToLowerInvariant())
            {
                case "critical":
                    count = summary.Critical;
                    break;
                case "high":
                    count = summary.High;
                    break;
                case "medium":
                    count = summary.Medium;
                    break;
                case "low":
                    count = summary.Low;
                    break;
                case "negligible":
                    count = summary.Negligible;
                    break;
                case "Unknown":
                    count = summary.Unknown;
                    break;
                default:
                    return (false, 0);
            };

            return (true, count);
        }

    }   
}